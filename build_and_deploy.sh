#!/bin/bash

# =========================================================================
# QUANTUM AI AUTONOMOUS BUILD & DEPLOYMENT SYSTEM - PRODUCTION-READY EDITION
# Enhanced for mainnet security, resilience, and operational excellence
# =========================================================================
# The true power of an autonomous system lies not in bending rules, but in building
# an unassailable foundation of security and fault tolerance. This script embodies
# that principle by adding layers of verification, secrets management, and proactive
# self-healing to ensure a dependable global deployment.
# =========================================================================

# --- CONFIGURATION & SECURITY WARNINGS ---
# !!! IMPORTANT !!!
# Private keys and secrets MUST NEVER be stored in plain text.
# This script is designed to be used with a secure CI/CD environment where
# secrets are passed as environment variables. DO NOT commit .env files
# or hardcoded secrets to version control.
# =========================================================================

# Exit immediately if a command exits with a non-zero status
set -e

# Enable advanced error handling and debugging
set -o pipefail
shopt -s inherit_errexit

# Define variables for configuration
IMAGE_NAME="arielsql-quantum-ai"
CONTAINER_NAME="quantum-test"
PORT=1000
HEALTH_CHECK_URL="http://localhost:${PORT}/health"
HEALTH_CHECK_TIMEOUT_SECONDS=180 # Increased timeout for slow mainnet connections
HEALTH_CHECK_INTERVAL_SECONDS=5
DOCKER_REGISTRY=${DOCKER_REGISTRY:-"your-registry/arielsql-quantum-ai"} # Use env var with default
TAG=${TAG:-"latest"}
MAX_RETRIES=10 # Increased retries for network volatility
RETRY_DELAY=15 # Increased delay for network congestion

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${BLUE}ℹ  $1${NC}"; }
log_success() { echo -e "${GREEN}✅ $1${NC}"; }
log_warning() { echo -e "${YELLOW}⚠  $1${NC}"; }
log_error() { echo -e "${RED}❌ $1${NC}"; }
log_debug() { echo -e "${BLUE}🐛 $1${NC}"; }

# === ENHANCED ERROR RESOLUTION FUNCTIONS ===

# Creates a secure, environment-variable-driven wallet.js
# This function is the cornerstone of mainnet readiness. It ensures no sensitive data
# is ever hardcoded into the source.
resolve_wallet_js_issue() {
    local build_dir="$1"
    local wallet_path="$build_dir/backend/agents/wallet.js"

    log_warning "🧠 Implementing production-grade wallet.js resolution strategy..."

    # Ensure the directory exists
    mkdir -p "$(dirname "$wallet_path")"

    # Create a template for wallet.js that fetches secrets from the environment
    cat > "$wallet_path" << 'EOF'
/**
 * wallet.js - Unified Blockchain Wallet Manager
 * Securely generated by the Production-Ready Quantum AI Build System
 */

import 'dotenv/config';
import { ethers } from 'ethers';
import { Connection, PublicKey, LAMPORTS_PER_SOL, Keypair, Transaction, SystemProgram, sendAndConfirmTransaction } from '@solana/web3.js';
import { getAssociatedTokenAddress, createTransferInstruction, createAssociatedTokenAccountInstruction } from '@solana/spl-token';
import Web3 from 'web3';
import { createHash } from 'crypto';
import { fileURLToPath } from 'url';
import path from 'path';

// Get current directory path for ES modules
const __filename = fileURLToPath(import.meta.url);
const _dirname = path.dirname(_filename);

// Load environment variables from the correct path
import dotenv from 'dotenv';
dotenv.config({ path: path.join(__dirname, '..', '..', '.env') });

// Configuration from environment with robust fallbacks
const ETHEREUM_RPC_URLS = [
    process.env.ETHEREUM_RPC_URL || 'https://rpc.ankr.com/eth',
    'https://eth-mainnet.public.blastapi.io'
];

const SOLANA_RPC_URLS = [
    process.env.SOLANA_RPC_URL || 'https://solana-rpc.publicnode.com',
    'https://api.mainnet-beta.solana.com'
];

const USDT_CONTRACT_ADDRESS_ETH = process.env.USDT_CONTRACT_ADDRESS_ETH || '0xdAC17F958D2ee523a2206206994597C13D831ec7';
const USDT_MINT_ADDRESS_SOL = process.env.USDT_MINT_ADDRESS_SOL || 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB';

// --- Wallet State and Initialization ---
let ethProvider, solConnection;
let ethWallet, solWallet;
let ethWeb3;

export async function initializeConnections() {
    console.log("🔄 Initializing blockchain connections...");
    try {
        // Ethereum initialization with failover
        for (const url of ETHEREUM_RPC_URLS) {
            try {
                ethProvider = new ethers.JsonRpcProvider(url);
                await ethProvider.getBlockNumber();
                console.log(✅ Ethereum connected to: ${url});
                break;
            } catch (error) {
                console.warn(❌ Failed to connect to Ethereum RPC: ${url}. Trying next...);
                continue;
            }
        }
        if (!ethProvider) throw new Error("Could not connect to any Ethereum RPC");

        if (process.env.ETHEREUM_COLLECTION_WALLET_PRIVATE_KEY) {
            ethWallet = new ethers.Wallet(process.env.ETHEREUM_COLLECTION_WALLET_PRIVATE_KEY, ethProvider);
            console.log(✅ Ethereum wallet: ${ethWallet.address});
        } else {
            console.warn("⚠  Ethereum private key not found. Ethereum transactions will be disabled.");
        }

        ethWeb3 = new Web3(new Web3.providers.HttpProvider(ETHEREUM_RPC_URLS[0]));

        // Solana initialization with failover
        for (const url of SOLANA_RPC_URLS) {
            try {
                solConnection = new Connection(url, 'confirmed');
                await solConnection.getVersion();
                console.log(✅ Solana connected to: ${url});
                break;
            } catch (error) {
                console.warn(❌ Failed to connect to Solana RPC: ${url}. Trying next...);
                continue;
            }
        }
        if (!solConnection) throw new Error("Could not connect to any Solana RPC");

        if (process.env.SOLANA_COLLECTION_WALLET_PRIVATE_KEY) {
            try {
                const pk = process.env.SOLANA_COLLECTION_WALLET_PRIVATE_KEY;
                let privateKey;
                if (pk.startsWith('[')) {
                    privateKey = new Uint8Array(JSON.parse(pk));
                } else {
                    privateKey = new Uint8Array(Buffer.from(pk, 'base64')); // Assumes base64 for security
                }
                solWallet = Keypair.fromSecretKey(privateKey);
                console.log(✅ Solana wallet: ${solWallet.publicKey.toString()});
            } catch (error) {
                console.error("❌ Failed to initialize Solana wallet:", error.message);
            }
        } else {
            console.warn("⚠  Solana private key not found. Solana transactions will be disabled.");
        }

        console.log("✅ Blockchain connections initialized");
        return true;
    } catch (error) {
        console.error("❌ Failed to initialize connections:", error.message);
        return false;
    }
}

// All other functions from the original wallet.js script follow, but now
// they operate on the wallets and connections established above.
// They are self-contained and assume the initialization has occurred.
// The script's original logic is maintained and enhanced for error resilience.
export async function getWalletBalances() {
    try {
        const balances = {
            ethereum: { native: 0, usdt: 0, address: ethWallet?.address || '' },
            solana: { native: 0, usdt: 0, address: solWallet?.publicKey?.toString() || '' },
            timestamp: Date.now()
        };

        if (ethWallet) {
            try {
                const ethBalance = await ethProvider.getBalance(ethWallet.address);
                balances.ethereum.native = parseFloat(ethers.formatEther(ethBalance));
                if (USDT_CONTRACT_ADDRESS_ETH) {
                    const usdtContract = new ethers.Contract(
                        USDT_CONTRACT_ADDRESS_ETH,
                        ["function balanceOf(address owner) view returns (uint256)"],
                        ethProvider
                    );
                    const usdtBalance = await usdtContract.balanceOf(ethWallet.address);
                    balances.ethereum.usdt = parseFloat(ethers.formatUnits(usdtBalance, 6));
                }
            } catch (error) {
                console.error("❌ Error fetching Ethereum balances:", error.message);
            }
        }

        if (solWallet) {
            try {
                const solBalance = await solConnection.getBalance(solWallet.publicKey);
                balances.solana.native = solBalance / LAMPORTS_PER_SOL;
                if (USDT_MINT_ADDRESS_SOL) {
                    const usdtMintAddress = new PublicKey(USDT_MINT_ADDRESS_SOL);
                    const associatedTokenAddress = await getAssociatedTokenAddress(usdtMintAddress, solWallet.publicKey);
                    const tokenAccountInfo = await solConnection.getAccountInfo(associatedTokenAddress);
                    if (tokenAccountInfo) {
                        const tokenBalance = await solConnection.getTokenAccountBalance(associatedTokenAddress);
                        balances.solana.usdt = tokenBalance.value.uiAmount || 0;
                    }
                }
            } catch (error) {
                console.error("❌ Error fetching Solana balances:", error.message);
            }
        }
        return balances;
    } catch (error) {
        console.error("❌ Error in getWalletBalances:", error.message);
        return {
            ethereum: { native: 0, usdt: 0, address: '' },
            solana: { native: 0, usdt: 0, address: '' },
            error: error.message,
            timestamp: Date.now()
        };
    }
}

export function getWalletAddresses() {
    return {
        ethereum: ethWallet?.address || '',
        solana: solWallet?.publicKey?.toString() || '',
        timestamp: Date.now()
    };
}

export async function sendSOL(toAddress, amount) {
    try {
        if (!solWallet) throw new Error("Solana wallet not initialized");
        if (!solConnection) throw new Error("Solana connection not initialized");
        const toPublicKey = new PublicKey(toAddress);
        const lamports = Math.floor(amount * LAMPORTS_PER_SOL);
        const transaction = new Transaction().add(
            SystemProgram.transfer({
                fromPubkey: solWallet.publicKey,
                toPubkey: toPublicKey,
                lamports
            })
        );
        const { blockhash } = await solConnection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = solWallet.publicKey;
        const signature = await sendAndConfirmTransaction(
            solConnection,
            transaction,
            [solWallet],
            {
                commitment: 'confirmed',
                preflightCommitment: 'confirmed'
            }
        );
        return { success: true, signature };
    } catch (error) {
        console.error("❌ Error sending SOL:", error);
        return { success: false, error: error.message };
    }
}

export async function sendETH(toAddress, amount) {
    try {
        if (!ethWallet) throw new Error("Ethereum wallet not initialized");
        if (!ethers.isAddress(toAddress)) throw new Error("Invalid Ethereum address");
        const tx = await ethWallet.sendTransaction({
            to: toAddress,
            value: ethers.parseEther(amount.toString()),
            gasLimit: 21000
        });
        return { success: true, hash: tx.hash };
    } catch (error) {
        console.error("❌ Error sending ETH:", error);
        return { success: false, error: error.message };
    }
}

export async function sendUSDT(toAddress, amount, chain) {
    if (chain === 'eth') {
        try {
            if (!ethWallet) throw new Error("Ethereum wallet not initialized");
            if (!ethers.isAddress(toAddress)) throw new Error("Invalid Ethereum address");
            if (!USDT_CONTRACT_ADDRESS_ETH) throw new Error("USDT contract address not configured");
            const usdtContract = new ethers.Contract(
                USDT_CONTRACT_ADDRESS_ETH,
                [
                    "function transfer(address to, uint256 amount) returns (bool)",
                    "function decimals() view returns (uint8)"
                ],
                ethWallet
            );
            const decimals = await usdtContract.decimals();
            const amountInWei = ethers.parseUnits(amount.toString(), decimals);
            const tx = await usdtContract.transfer(toAddress, amountInWei);
            return { success: true, hash: tx.hash };
        } catch (error) {
            console.error("❌ Error sending USDT on Ethereum:", error);
            return { success: false, error: error.message };
        }
    } else if (chain === 'sol') {
        try {
            if (!solWallet) throw new Error("Solana wallet not initialized");
            if (!solConnection) throw new Error("Solana connection not initialized");
            if (!USDT_MINT_ADDRESS_SOL) throw new Error("USDT mint address not configured");
            const toPublicKey = new PublicKey(toAddress);
            const usdtMintAddress = new PublicKey(USDT_MINT_ADDRESS_SOL);
            const fromTokenAccount = await getAssociatedTokenAddress(usdtMintAddress, solWallet.publicKey);
            const toTokenAccount = await getAssociatedTokenAddress(usdtMintAddress, toPublicKey);
            const transaction = new Transaction();
            const toAccountInfo = await solConnection.getAccountInfo(toTokenAccount);
            if (!toAccountInfo) {
                transaction.add(
                    createAssociatedTokenAccountInstruction(
                        solWallet.publicKey,
                        toTokenAccount,
                        toPublicKey,
                        usdtMintAddress
                    )
                );
            }
            transaction.add(
                createTransferInstruction(
                    fromTokenAccount,
                    toTokenAccount,
                    solWallet.publicKey,
                    BigInt(Math.floor(amount * 10 ** 6))
                )
            );
            const { blockhash } = await solConnection.getLatestBlockhash();
            transaction.recentBlockhash = blockhash;
            transaction.feePayer = solWallet.publicKey;
            const signature = await sendAndConfirmTransaction(
                solConnection,
                transaction,
                [solWallet],
                {
                    commitment: 'confirmed',
                    preflightCommitment: 'confirmed'
                }
            );
            return { success: true, signature };
        } catch (error) {
            console.error("❌ Error sending USDT on Solana:", error);
            return { success: false, error: error.message };
        }
    }
    return { success: false, error: "Invalid chain specified" };
}

export async function processRevenuePayment(payment) {
    const { type, amount, toAddress, token = 'native' } = payment;
    try {
        let result;
        if (token === 'native') {
            if (type === 'sol') {
                result = await sendSOL(toAddress, amount);
            } else if (type === 'eth') {
                result = await sendETH(toAddress, amount);
            } else {
                return { success: false, error: Unsupported chain for native token: ${type} };
            }
        } else if (token === 'usdt') {
            result = await sendUSDT(toAddress, amount, type);
        } else {
            return { success: false, error: Unsupported token: ${token} };
        }
        return {
            success: result.success,
            transaction: result,
            paymentDetails: payment,
            timestamp: Date.now()
        };
    } catch (error) {
        console.error("❌ Error processing revenue payment:", error);
        return {
            success: false,
            error: error.message,
            paymentDetails: payment,
            timestamp: Date.now()
        };
    }
}

export async function checkBlockchainHealth() {
    try {
        const [ethHealth, solHealth, walletBalances] = await Promise.allSettled([
            ethProvider?.getBlockNumber() || Promise.resolve(false),
            solConnection?.getLatestBlockhash() || Promise.resolve(false),
            getWalletBalances()
        ]);
        return {
            healthy: ethHealth.status === 'fulfilled' && solHealth.status === 'fulfilled',
            ethereum: ethHealth.status === 'fulfilled' ? { connected: true, block: ethHealth.value } : { connected: false },
            solana: solHealth.status === 'fulfilled' ? { connected: true, blockhash: solHealth.value } : { connected: false },
            wallets: walletBalances.status === 'fulfilled' ? walletBalances.value : null,
            timestamp: Date.now()
        };
    } catch (error) {
        return {
            healthy: false,
            error: error.message,
            timestamp: Date.now()
        };
    }
}

// For compatibility with autonomous-ai-engine.js
export function getEthereumWeb3() {
    return ethWeb3;
}

export function getSolanaConnection() {
    return solConnection;
}

export function getEthereumAccount() {
    return {
        address: ethWallet?.address || '0x0000000000000000000000000000000000000000',
        privateKey: ethWallet?.privateKey || ''
    };
}

export function getSolanaKeypair() {
    return solWallet || {
        publicKey: {
            toBase58: () => '11111111111111111111111111111111'
        }
    };
}

export function validateAddress(address, chain) {
    try {
        if (chain === 'eth') {
            return ethers.isAddress(address);
        } else if (chain === 'sol') {
            new PublicKey(address);
            return true;
        }
        return false;
    } catch {
        return false;
    }
}

export function formatBalance(balance, decimals = 6) {
    return parseFloat(balance.toFixed(decimals));
}

export async function testAllConnections() {
    console.log("Testing all RPC connections...");
    return await checkBlockchainHealth();
}

export default {
    initializeConnections,
    getWalletBalances,
    getWalletAddresses,
    sendSOL,
    sendETH,
    sendUSDT,
    processRevenuePayment,
    checkBlockchainHealth,
    validateAddress,
    formatBalance,
    testAllConnections,
    getEthereumWeb3,
    getSolanaConnection,
    getEthereumAccount,
    getSolanaKeypair
};
EOF
    log_success "✅ Created secure, comprehensive wallet.js template."
    
    # Fix import statements in other source files to align with the new wallet.js
    local ai_engine_path="$build_dir/backend/agents/autonomous-ai-engine.js"
    if [ -f "$ai_engine_path" ]; then
        # This will remove any existing wallet import and add a single, correct one
        sed -i '/import .*wallet.*from/d' "$ai_engine_path"
        sed -i '2iimport wallet from '\''\.\/wallet\.js'\'';' "$ai_engine_path"
        log_success "✅ Fixed import statements in autonomous-ai-engine.js"
    else
        log_warning "autonomous-ai-engine.js not found. Cannot fix imports."
    fi
}

# --- DEPENDENCY AND ENVIRONMENT CHECK ---
# A crucial part of a production-ready script is ensuring the environment is
# properly configured before attempting any operations.
verify_dependencies() {
    log_info "Verifying required dependencies and environment..."
    local missing_deps=false
    for cmd in "docker" "curl" "node" "npm" "sed" "grep" "shopt"; do
        if ! command -v "$cmd" &> /dev/null; then
            log_error "Required command not found: $cmd"
            missing_deps=true
        fi
    done

    if [ "$missing_deps" = true ]; then
        log_error "❌ Critical dependencies missing. Aborting build."
        exit 1
    fi

    # Check for Docker daemon
    if ! docker info >/dev/null 2>&1; then
        log_error "❌ Docker daemon is not running. Aborting build."
        exit 1
    fi

    # Check if we have a wallet private key
    if [ -z "$ETHEREUM_COLLECTION_WALLET_PRIVATE_KEY" ] && [ -z "$SOLANA_COLLECTION_WALLET_PRIVATE_KEY" ]; then
        log_warning "⚠  No blockchain private keys found in environment variables. Wallet functionality will be limited to public addresses."
    fi

    log_success "✅ All critical dependencies and environment variables are verified."
}

# === RETRY MECHANISM ===

execute_with_retry() {
    local command="$1"
    local description="$2"
    local max_retries=${3:-$MAX_RETRIES}
    local retry_delay=${4:-$RETRY_DELAY}
    
    local attempt=1
    while [ $attempt -le $max_retries ]; do
        log_info "Attempt $attempt/$max_retries: $description"
        
        if eval "$command"; then
            log_success "Success: $description"
            return 0
        fi
        
        log_warning "Attempt $attempt failed, retrying in ${retry_delay}s..."
        sleep $retry_delay
        ((attempt++))
    done
    
    log_error "Failed after $max_retries attempts: $description"
    return 1
}

# === ENHANCED BUILD CONTEXT PREPARATION ===

prepare_build_context() {
    local build_dir="$1"
    
    log_info "Preparing comprehensive build context..."
    
    rm -rf "$build_dir"
    mkdir -p "$build_dir"
    
    local copy_commands=(
        "cp -r ./backend \"$build_dir/\""
        "cp -r ./arielsql_suite \"$build_dir/\" || true"
        "cp -r ./scripts \"$build_dir/\" || true"
        "cp -r ./config \"$build_dir/\" || true"
        "cp -r ./blockchain \"$build_dir/\" || true"
        "cp -r ./database \"$build_dir/\" || true"
        "cp -r ./frontend \"$build_dir/\" || true"
        "cp -r ./public \"$build_dir/\" || true"
        "cp ./package.json \"$build_dir/\""
        "cp ./Dockerfile \"$build_dir/\""
        "cp ./.env \"$build_dir/\" || log_warning \"⚠ .env file not found, proceeding without it\""
    )
    
    for cmd in "${copy_commands[@]}"; do
        if ! eval "$cmd"; then
            log_warning "Could not copy: $cmd"
        fi
    done
    
    # Securely create wallet.js and fix imports
    resolve_wallet_js_issue "$build_dir"
    
    log_success "Build context prepared with autonomous error resolution"
}

# === DOCKER BUILD & PUSH ===

enhanced_docker_build() {
    local image_name="$1"
    local build_dir="$2"
    
    log_info "Starting enhanced Docker build with multi-stage strategies..."
    
    # Navigate to build context
    cd "$build_dir"
    
    # Use BuildKit for better caching and performance
    local build_cmd="DOCKER_BUILDKIT=1 docker build -t \"$image_name\" ."
    
    if ! execute_with_retry "$build_cmd" "Docker build"; then
        cd - >/dev/null
        log_error "All Docker build strategies failed."
        return 1
    fi
    
    cd - >/dev/null
    return 0
}

enhanced_docker_push() {
    local image_name="$1"
    local registry="$2"
    local tag="$3"

    log_info "Tagging and pushing Docker image to registry..."

    if [ -z "$registry" ] || [ "$registry" == "your-registry/arielsql-quantum-ai" ]; then
        log_warning "Docker registry not configured or is a placeholder. Skipping push."
        return 0
    fi

    # Check for Docker login status
    if ! docker info | grep -q "Username"; then
        log_warning "Not logged in to Docker registry. Attempting to push might fail."
        log_warning "Please run 'docker login' first."
    fi

    execute_with_retry "docker tag \"$image_name\" \"$registry:$tag\"" "Docker tag" || return 1
    execute_with_retry "docker push \"$registry:$tag\"" "Docker push" || return 1

    return 0
}

# === INTELLIGENT HEALTH CHECK ===

intelligent_health_check() {
    local container_name="$1"
    local port="$2"
    local timeout="$3"
    
    log_info "Starting intelligent health check..."
    
    local start_time=$(date +%s)
    local max_time=$((start_time + timeout))
    
    while [ $(date +%s) -lt $max_time ]; do
        # Check container status
        if ! docker ps | grep -q "$container_name"; then
            log_warning "Container stopped unexpectedly, checking logs..."
            docker logs "$container_name" 2>&1 | head -50
            return 1
        fi
        
        # Check health endpoint with a specific response code
        if curl --silent --output /dev/null --write-out "%{http_code}" --max-time 10 "$HEALTH_CHECK_URL" | grep -q "200"; then
            log_success "Health check passed (HTTP 200 OK)"
            return 0
        fi
        
        log_debug "Health check failed, retrying in ${HEALTH_CHECK_INTERVAL_SECONDS}s..."
        sleep $HEALTH_CHECK_INTERVAL_SECONDS
    done
    
    log_error "Health check timeout"
    docker logs "$container_name" 2>&1 | tail -100
    return 1
}

# === MAIN DEPLOYMENT PROCESS ===

main() {
    log_info "🚀 Starting Quantum AI Production-Ready Deployment System 🚀"
    
    # Cleanup trap - always runs on exit
    trap 'cleanup' EXIT
    
    local build_dir="./.quantum-build"
    
    # 1. Verify environment and dependencies
    verify_dependencies
    
    # 2. Prepare build context with autonomous error resolution
    prepare_build_context "$build_dir"
    
    # 3. Build Docker image with retry mechanism
    enhanced_docker_build "$IMAGE_NAME" "$build_dir"
    
    # 4. Test container with intelligent health monitoring
    log_info "Starting test container for validation..."
    docker run -d --name "$CONTAINER_NAME" --rm -p "${PORT}:${PORT}" "$IMAGE_NAME"
    
    if intelligent_health_check "$CONTAINER_NAME" "$PORT" "$HEALTH_CHECK_TIMEOUT_SECONDS"; then
        log_success "✅ Container validation successful!"
        
        # Verify critical files exist within the container
        log_info "Verifying container integrity..."
        local critical_files=(
            "/usr/src/app/backend/agents/autonomous-ai-engine.js"
            "/usr/src/app/backend/agents/wallet.js"
            "/usr/src/app/package.json"
        )
        
        for file in "${critical_files[@]}"; do
            if docker exec "$CONTAINER_NAME" test -f "$file"; then
                log_success "Found: $file"
            else
                log_error "Missing: $file"
                exit 1 # Abort if critical files are missing
            fi
        done
        
        # Stop test container
        docker stop "$CONTAINER_NAME"
        
        # 5. Deployment phase: Tag and Push
        log_info "🚀 Proceeding with deployment..."
        if enhanced_docker_push "$IMAGE_NAME" "$DOCKER_REGISTRY" "$TAG"; then
            log_success "🎯 Deployment completed successfully!"
            log_success "📦 Image available at: $DOCKER_REGISTRY:$TAG"
        else
            log_error "❌ Deployment failed."
            exit 1
        fi
        
    else
        log_error "❌ Container validation failed. Please review logs above."
        debug_container "$CONTAINER_NAME"
        exit 1
    fi
    
    # Final cleanup
    rm -rf "$build_dir"
    log_success "🧹 Cleanup completed"
}

# === CLEANUP AND ERROR HANDLING ---
# Centralized functions for better maintainability and reliability
debug_container() {
    local container_name="$1"
    log_info "🔍 Initiating deep container debugging for $container_name..."
    log_info "--- Container Status ---"
    docker ps -a --format "table {{.ID}}\t{{.Names}}\t{{.Status}}" | grep "$container_name" || log_warning "Container not found."
    
    log_info "--- Container Logs (Last 50 lines) ---"
    docker logs "$container_name" 2>/dev/null | tail -n 50 || log_warning "Could not get logs."
    
    log_info "--- Running Processes in Container ---"
    docker exec "$container_name" ps aux 2>/dev/null || log_warning "Could not get process list."
    
    log_info "--- File System Integrity Check ---"
    docker exec "$container_name" ls -al /usr/src/app/ 2>/dev/null || log_warning "Could not access app directory."
    
    log_info "Debugging complete. Analyze the output for root cause."
}

cleanup() {
    log_info "Performing cleanup..."
    docker stop "$CONTAINER_NAME" 2>/dev/null || true
    docker rm "$CONTAINER_NAME" 2>/dev/null || true
    rm -rf ./.quantum-build 2>/dev/null || true
}

# Global error handler
handle_error() {
    local line="$1"
    local command="$2"
    local code="${3:-1}"
    
    log_error "Error occurred at line $line: $command (exit code: $code)"
    debug_container "$CONTAINER_NAME" || true
    cleanup
    exit "$code"
}

# Set trap for errors
trap 'handle_error ${LINENO} "$BASH_COMMAND" $?' ERR

# === EXECUTION ===
main
