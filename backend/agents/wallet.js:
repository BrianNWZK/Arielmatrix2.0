/**
 * Automated Multi-Chain Fund Consolidation Script
 *
 * This utility connects to a list of RPC endpoints and uses the fastest one available.
 * This approach enhances reliability by providing resilience against network
 * congestion and individual node failures.
 */

import 'dotenv/config'; // Loads environment variables
import { ethers } from 'ethers';
import { Connection, PublicKey, LAMPORTS_PER_SOL, Keypair, Transaction, SystemProgram, sendAndConfirmTransaction } from '@solana/web3.js';
import { getAssociatedTokenAddress, createTransferInstruction } from '@solana/spl-token';

// =========================================================================
// 1. Configuration - HARDCODED RPCs and Public Information
// =========================================================================
// Hardcoded Mainnet RPC URLs for redundancy and quick setup. These are public and not a security risk.
const ETHEREUM_RPC_URLS = [
    'https://rpc.ankr.com/multichain/43c6febde6850df38b14e31c2c5b293900a1ec693acf36108e43339cf57f8f97'
];

const SOLANA_RPC_URLS = [
    'https://solana-rpc.publicnode.com'
];

// Public addresses for stablecoins
const USDT_CONTRACT_ADDRESS_ETH = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
const USDT_MINT_ADDRESS_SOL = 'Es9Kdd31Wq41G4R7s3M2wXq3T413d7tLg484e1t4t';

// =========================================================================
// 2. Private Keys from .env - MANDATORY FOR SECURITY
// =========================================================================
const ETH_COLLECTION_WALLET_PRIVATE_KEY = process.env.ETHEREUM_COLLECTION_WALLET_PRIVATE_KEY;
const SOL_COLLECTION_WALLET_PRIVATE_KEY = process.env.SOLANA_COLLECTION_WALLET_PRIVATE_KEY;

// =========================================================================
// 3. RPC Connection Management
// =========================================================================
/**
 * Finds the fastest RPC URL from a list by attempting a connection to each in parallel.
 * @param {string[]} rpcUrls - An array of RPC URLs.
 * @param {string} chainName - The name of the blockchain for logging.
 * @returns {Promise<string>} The URL of the fastest responding RPC.
 */
async function getFastestRPC(rpcUrls, chainName) {
    console.log(`\nTesting ${chainName} RPC endpoints to find the fastest connection...`);
    
    // Create a promise for each RPC URL to test its connection
    const connectionPromises = rpcUrls.map(url => {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error(`Timeout connecting to ${url}`));
            }, 5000); // 5-second timeout

            // Use a simple fetch to check if the endpoint is reachable
            fetch(url, { method: 'POST', body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'eth_blockNumber', params: [] }), headers: { 'Content-Type': 'application/json' } })
                .then(res => {
                    clearTimeout(timeout);
                    if (res.ok) {
                        console.log(`✅ Connected to ${chainName} via: ${url}`);
                        resolve(url);
                    } else {
                        reject(new Error(`Failed to connect to ${url}`));
                    }
                })
                .catch(err => {
                    clearTimeout(timeout);
                    reject(new Error(`Network error for ${url}: ${err.message}`));
                });
        });
    });

    try {
        // Promise.any() resolves as soon as one of the promises in the array resolves
        const fastestUrl = await Promise.any(connectionPromises);
        return fastestUrl;
    } catch (error) {
        console.error(`❌ All ${chainName} RPC connections failed. Using the first URL as fallback.`);
        return rpcUrls[0];
    }
}

/**
 * Logs the status of all configured RPC connections simultaneously.
 */
export async function testAllConnections() {
    console.log("Simultaneously testing all RPC endpoints:");
    const ethPromises = ETHEREUM_RPC_URLS.map(async url => {
        try {
            const provider = new ethers.JsonRpcProvider(url);
            await provider.getBlockNumber();
            console.log(`✅ Ethereum RPC connected: ${url}`);
        } catch (error) {
            console.log(`❌ Ethereum RPC failed: ${url} (${error.message})`);
        }
    });

    const solPromises = SOLANA_RPC_URLS.map(async url => {
        try {
            const connection = new Connection(url, 'confirmed');
            await connection.getLatestBlockhash();
            console.log(`✅ Solana RPC connected: ${url}`);
        } catch (error) {
            console.log(`❌ Solana RPC failed: ${url} (${error.message})`);
        }
    });

    await Promise.allSettled([...ethPromises, ...solPromises]);
}

// Global connection variables
let ethProvider, solConnection;
let ethWallet, solWallet;

// =========================================================================
// 4. Initialization
// =========================================================================
/**
 * Initializes all blockchain connections. Must be called before any other function.
 */
export async function initializeConnections() {
    // Solana Initialization
    const solanaRpcUrl = await getFastestRPC(SOLANA_RPC_URLS, 'Solana');
    solConnection = new Connection(solanaRpcUrl, 'confirmed');
    
    // Check if private key is provided
    if (!SOL_COLLECTION_WALLET_PRIVATE_KEY) {
        throw new Error("Solana private key is missing from .env file.");
    }
    solWallet = Keypair.fromSecretKey(Uint8Array.from(JSON.parse(SOL_COLLECTION_WALLET_PRIVATE_KEY)));

    // Ethereum Initialization
    const ethereumRpcUrl = await getFastestRPC(ETHEREUM_RPC_URLS, 'Ethereum');
    ethProvider = new ethers.JsonRpcProvider(ethereumRpcUrl);

    // Check if private key is provided
    if (!ETH_COLLECTION_WALLET_PRIVATE_KEY) {
        throw new Error("Ethereum private key is missing from .env file.");
    }
    ethWallet = new ethers.Wallet(ETH_COLLECTION_WALLET_PRIVATE_KEY, ethProvider);
}

// =========================================================================
// 5. Wallet Functions
// =========================================================================
/**
 * Retrieves the SOL balance of the operational wallet.
 * @returns {Promise<number>} The balance in SOL.
 */
export async function getSolanaBalance() {
    try {
        const balance = await solConnection.getBalance(solWallet.publicKey);
        return balance / LAMPORTS_PER_SOL;
    } catch (error) {
        console.error("Error fetching Solana balance:", error);
        return 0;
    }
}

/**
 * Sends native SOL from the operational wallet to a destination.
 * @param {string} toAddress - The recipient's Solana address.
 * @param {number} amount - The amount of SOL to send.
 * @returns {Promise<object>} The transaction details or an error object.
 */
export async function sendSOL(toAddress, amount) {
    try {
        const toPublicKey = new PublicKey(toAddress);
        const lamports = amount * LAMPORTS_PER_SOL;
        const transaction = new Transaction().add(SystemProgram.transfer({ fromPubkey: solWallet.publicKey, toPubkey: toPublicKey, lamports }));
        const { blockhash, lastValidBlockHeight } = await solConnection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.lastValidBlockHeight = lastValidBlockHeight;
        transaction.feePayer = solWallet.publicKey;
        const signature = await sendAndConfirmTransaction(solConnection, transaction, [solWallet]);
        return { signature };
    } catch (error) {
        console.error("Error sending SOL:", error);
        return { error: error.message };
    }
}

/**
 * Retrieves the USDT balance of the operational wallet on both chains.
 * @param {string} chain - The blockchain to check ('eth' or 'sol').
 * @returns {Promise<number>} The USDT balance.
 */
export async function getUSDTBalance(chain = 'eth') {
    if (chain === 'eth') {
        const usdtContract = new ethers.Contract(USDT_CONTRACT_ADDRESS_ETH, ["function balanceOf(address owner) view returns (uint256)"], ethProvider);
        const balance = await usdtContract.balanceOf(ethWallet.address);
        return ethers.formatUnits(balance, 6);
    } else if (chain === 'sol') {
        try {
            const usdtMintAddress = new PublicKey(USDT_MINT_ADDRESS_SOL);
            const associatedTokenAddress = await getAssociatedTokenAddress(usdtMintAddress, solWallet.publicKey);
            const tokenBalance = await solConnection.getTokenAccountBalance(associatedTokenAddress);
            return tokenBalance.value.uiAmount;
        } catch (error) {
            console.error("Error fetching Solana USDT balance:", error);
            return 0;
        }
    }
    return 0;
}

/**
 * Sends USDT from the operational wallet to a destination.
 * @param {string} toAddress - The recipient's address.
 * @param {number} amount - The amount of USDT to send.
 * @param {string} chain - The blockchain to send on ('eth' or 'sol').
 * @returns {Promise<object>} The transaction details.
 */
export async function sendUSDT(toAddress, amount, chain) {
    if (chain === 'eth') {
        try {
            if (!ethers.isAddress(toAddress)) { throw new Error("Invalid Ethereum address."); }
            const usdtContract = new ethers.Contract(USDT_CONTRACT_ADDRESS_ETH, ["function transfer(address to, uint256 amount) returns (bool)"], ethWallet);
            const amountInWei = ethers.parseUnits(amount.toString(), 6);
            const tx = await usdtContract.transfer(toAddress, amountInWei);
            return { hash: tx.hash };
        } catch (ethError) {
            console.error("Error sending USDT on Ethereum:", ethError);
            return { error: ethError.message };
        }
    } else if (chain === 'sol') {
        try {
            const toPublicKey = new PublicKey(toAddress);
            const usdtMintAddress = new PublicKey(USDT_MINT_ADDRESS_SOL);
            const fromTokenAccount = await getAssociatedTokenAddress(usdtMintAddress, solWallet.publicKey);
            const toTokenAccount = await getAssociatedTokenAddress(usdtMintAddress, toPublicKey);
            const transaction = new Transaction().add(createTransferInstruction(fromTokenAccount, toTokenAccount, solWallet.publicKey, amount * 10 ** 6));
            const { blockhash, lastValidBlockHeight } = await solConnection.getLatestBlockhash();
            transaction.recentBlockhash = blockhash;
            transaction.lastValidBlockHeight = lastValidBlockHeight;
            transaction.feePayer = solWallet.publicKey;
            const signature = await sendAndConfirmTransaction(solConnection, transaction, [solWallet]);
            return { signature };
        } catch (solError) {
            console.error("Error sending USDT on Solana:", solError);
            return { error: solError.message };
        }
    } else {
        return { error: "Invalid chain specified. Please use 'eth' or 'sol'." };
    }
}
