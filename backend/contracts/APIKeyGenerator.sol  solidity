// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

/**
 * @title QuantumAPIKeyGenerator
 * @dev A smart contract for generating and managing API keys with enhanced security features.
 * It uses Chainlink price feeds as a source of off-chain entropy for key generation.
 * @custom:security: The term "Quantum-resistant" here refers to the use of a one-way cryptographic hash function (keccak256)
 * and external entropy, which makes key prediction computationally infeasible. It is not a formal post-quantum cryptographic scheme.
 */
contract QuantumAPIKeyGenerator is Ownable {
    // ===== QUANTUM SECURITY =====
    struct APIKey {
        bytes32 hashedKey;
        uint256 timestamp;
        uint256 expiration;
        uint256 accessLevel;
        bool isActive;
        uint256 nonce; // To prevent replay attacks and ensure key uniqueness
    }

    // ===== STORAGE =====
    mapping(address => APIKey) private _userKeys;
    mapping(address => bool) private _authorizedContracts;

    // ===== CHAINLINK PRICE FEED (For entropy) =====
    AggregatorV3Interface internal _priceFeed;

    // ===== EVENTS =====
    event KeyGenerated(address indexed user, uint256 timestamp);
    event KeyRevoked(address indexed user);
    event KeyUpgraded(address indexed user, uint256 newAccessLevel);

    // ===== CONSTRUCTOR =====
    constructor(address priceFeedAddress) Ownable(msg.sender) {
        _priceFeed = AggregatorV3Interface(priceFeedAddress);
    }

    // ===== CORE FUNCTIONS =====

    /**
     * @dev Generates a secure, unique API key hash for a user.
     * The key's entropy is derived from the user's address, block data, and a Chainlink price feed.
     * @param user The address for which to generate a key.
     * @return The newly generated API key hash.
     */
    function generateKey(address user) external returns (bytes32) {
        require(_userKeys[user].timestamp == 0, "Key already exists for user");

        // Get external entropy from Chainlink
        (
            ,
            int256 price,
            ,
            ,
        ) = _priceFeed.latestRoundData();
        
        // Use a nonce to ensure key uniqueness even with identical inputs
        uint256 newNonce = _userKeys[user].nonce + 1;
        
        // Generate a secure, one-way hash using multiple entropy sources
        bytes32 hashedKey = keccak256(
            abi.encodePacked(
                user,
                block.timestamp,
                block.chainid, // Use block.chainid as a consistent entropy source
                uint256(price), // External entropy
                newNonce
            )
        );

        // Store the key's hash and metadata
        _userKeys[user] = APIKey({
            hashedKey: hashedKey,
            timestamp: block.timestamp,
            expiration: block.timestamp + 365 days,
            accessLevel: 1, // Default: Base access
            isActive: true,
            nonce: newNonce
        });

        emit KeyGenerated(user, block.timestamp);
        return hashedKey;
    }

    /**
     * @dev Validates a given key hash against the stored hash and checks its status.
     * This is the function external systems would call to verify a user's API key.
     * @param user The address of the key's owner.
     * @param keyHash The hash of the API key provided by the user.
     * @return A boolean indicating if the key is valid.
     */
    function validateKey(address user, bytes32 keyHash) external view returns (bool) {
        APIKey storage apiKey = _userKeys[user];
        
        // Ensure the key is active, not expired, and the provided hash matches the stored hash
        return (
            apiKey.isActive &&
            block.timestamp <= apiKey.expiration &&
            keyHash == apiKey.hashedKey
        );
    }

    // ===== AI-ENHANCED FUNCTIONS =====

    /**
     * @dev Auto-upgrades key security by generating a new key hash with fresh entropy.
     * This function can be called by the owner if a potential security compromise is detected.
     * @param user The address of the key's owner.
     */
    function upgradeKeySecurity(address user) external onlyOwner {
        require(_userKeys[user].isActive, "Key inactive");
        
        // Generate new entropy from Chainlink
        (
            ,
            int256 price,
            ,
            ,
        ) = _priceFeed.latestRoundData();
        
        // Increment nonce to ensure uniqueness
        uint256 newNonce = _userKeys[user].nonce + 1;

        // Generate a new, unique hash
        bytes32 newHashedKey = keccak256(
            abi.encodePacked(
                _userKeys[user].hashedKey, // Include previous hash for key migration
                price,
                block.timestamp,
                newNonce
            )
        );
        
        _userKeys[user].hashedKey = newHashedKey;
        _userKeys[user].nonce = newNonce;
        _userKeys[user].accessLevel += 1;
        
        emit KeyUpgraded(user, _userKeys[user].accessLevel);
    }

    // ===== CROSS-CHAIN FUNCTIONS =====

    /**
     * @dev Allows authorized contracts to validate keys without knowing the user's address.
     * This is useful for privacy-preserving cross-chain validation.
     * @param user The user address associated with the key.
     * @param keyHash The hash of the API key to validate.
     * @return A boolean indicating if the key is valid.
     */
    function crossChainValidate(address user, bytes32 keyHash) external view returns (bool) {
        require(_authorizedContracts[msg.sender], "Unauthorized validator");
        return validateKey(user, keyHash);
    }
    
    /**
     * @dev Allows the owner to manually revoke a user's API key.
     * @param user The address of the key's owner.
     */
    function revokeKey(address user) external onlyOwner {
        _userKeys[user].isActive = false;
        emit KeyRevoked(user);
    }

    /**
     * @dev Allows the owner to authorize a new contract address for cross-chain validation.
     * @param contractAddress The address of the contract to authorize.
     */
    function addAuthorizedContract(address contractAddress) external onlyOwner {
        _authorizedContracts[contractAddress] = true;
    }
}
