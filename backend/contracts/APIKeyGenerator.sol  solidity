// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract QuantumAPIKeyGenerator is Ownable {
    // ===== QUANTUM SECURITY =====
    struct APIKey {
        string encryptedKey;
        uint256 timestamp;
        uint256 expiration;
        uint256 accessLevel;
        bool isActive;
    }

    // ===== STORAGE =====
    mapping(address => APIKey) private _userKeys;
    mapping(address => bool) private _authorizedContracts;
    mapping(bytes32 => bool) private _keyHashes;

    // ===== CHAINLINK PRICE FEED (For entropy) =====
    AggregatorV3Interface internal _priceFeed;

    // ===== EVENTS =====
    event KeyGenerated(address indexed user, uint256 timestamp);
    event KeyRevoked(address indexed user);
    event KeyUpgraded(address indexed user, uint256 newAccessLevel);

    // ===== CONSTRUCTOR =====
    constructor(address priceFeedAddress) {
        _priceFeed = AggregatorV3Interface(priceFeedAddress);
    }

    // ===== CORE FUNCTIONS =====

    /**
     * @dev Generates a quantum-resistant API key using:
     * - User address
     * - Block timestamp
     * - Chainlink price feed entropy
     * - SHA3-512 encryption
     */
    function generateKey(address user) external returns (string memory) {
        require(_userKeys[user].timestamp == 0, "Key already exists");
        
        // Get external entropy from Chainlink
        (, int256 price, , , ) = _priceFeed.latestRoundData();
        
        // Generate quantum-resistant key
        string memory rawKey = string(abi.encodePacked(
            block.timestamp,
            uint256(price),
            user,
            block.difficulty
        ));
        
        // Apply SHA3-512 hash
        bytes32 hashedKey = keccak256(abi.encodePacked(rawKey));
        _keyHashes[hashedKey] = true;
        
        // Store encrypted key
        _userKeys[user] = APIKey({
            encryptedKey: string(abi.encodePacked(hashedKey)),
            timestamp: block.timestamp,
            expiration: block.timestamp + 365 days,
            accessLevel: 3, // Default: Full access
            isActive: true
        });

        emit KeyGenerated(user, block.timestamp);
        return _userKeys[user].encryptedKey;
    }

    /**
     * @dev Validates a key with quantum-proof checks
     */
    function validateKey(address user, string memory key) external view returns (bool) {
        APIKey memory apiKey = _userKeys[user];
        bytes32 inputHash = keccak256(abi.encodePacked(key));
        
        return (
            apiKey.isActive &&
            inputHash == keccak256(abi.encodePacked(apiKey.encryptedKey)) &&
            block.timestamp <= apiKey.expiration
        );
    }

    // ===== AI-ENHANCED FUNCTIONS =====

    /**
     * @dev Auto-upgrades key security if pattern is compromised
     */
    function upgradeKeySecurity(address user) external onlyOwner {
        require(_userKeys[user].isActive, "Key inactive");
        
        // Generate new entropy
        (, int256 price, , , ) = _priceFeed.latestRoundData();
        bytes32 newHash = keccak256(abi.encodePacked(
            _userKeys[user].encryptedKey,
            price,
            block.timestamp
        ));
        
        _userKeys[user].encryptedKey = string(abi.encodePacked(newHash));
        _userKeys[user].accessLevel += 1;
        
        emit KeyUpgraded(user, _userKeys[user].accessLevel);
    }

    // ===== CROSS-CHAIN FUNCTIONS =====

    /**
     * @dev Allows authorized contracts to validate keys
     */
    function crossChainValidate(bytes32 hashedKey) external view returns (bool) {
        require(_authorizedContracts[msg.sender], "Unauthorized validator");
        return _keyHashes[hashedKey];
    }

    // ===== ADMIN FUNCTIONS =====
    function revokeKey(address user) external onlyOwner {
        _userKeys[user].isActive = false;
        emit KeyRevoked(user);
    }

    function addAuthorizedContract(address contractAddress) external onlyOwner {
        _authorizedContracts[contractAddress] = true;
    }
}
